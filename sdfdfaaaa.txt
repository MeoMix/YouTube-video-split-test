document.write('<!DOCTYPE html>'+
'<html lang="en" dir="ltr" data-cast-api-enabled="true">'+

'<head>'+
    '<title>Disclosure - You &amp; Me (Flume Remix) - YouTube</title>'+
    '<link rel="canonical" href="http://www.youtube.com/watch?v=OUkkaqSNduU">'+
    '<link rel="stylesheet" href="https://s.ytimg.com/yts/cssbin/www-embed-player-webp-vfl5oEKQT.css" name="www-embed-player">'+
    '<script src="' + chrome.runtime.getURL('inline.js') +'"></script>'+
'</head>'+


'<body id="" class="date-20150226 en_US ltr  exp-a exp-c exp-h exp-k exp-s exp-t exp-w exp-y  site-center-aligned site-as-giant-card webkit webkit-537" dir="ltr">'+
    '<div id="player" class="full-frame"></div>'+
    '<div id="player-unavailable" class="ytp-error hid">'+
        '<div id="unavailable-submessage" class="ytp-error-content"></div>'+
    '</div>'+
    '<script src="' + chrome.runtime.getURL('embedplayer.js') + '" type="text/javascript" name="www-embed-player/www-embed-player"></script>'+
	'<script src="' + chrome.runtime.getURL('html5player.js') + '" type="text/javascript" name="www-embed-player/www-embed-player"></script>'+
    '<script src="' + chrome.runtime.getURL('inline2.js') +'"></script>'+
    '<script src="' + chrome.runtime.getURL('inline3.js') +'"></script>'+
'</body>'+

'</html>');

var loaderPort = chrome.runtime.connect({
    name: 'loader'
});

// window.addEventListener('message', function(request){
	// loaderPort.postMessage(request.data);
// });

setTimeout(function(){
var FILE = chrome.runtime.getURL('test.webm');
var NUM_CHUNKS = 5;

  GET(FILE, function(uInt8Array) {
    var file = new Blob([uInt8Array], {type: 'video/webm'});
    var chunkSize = Math.ceil(file.size / NUM_CHUNKS);
	console.log('file size and chunk size:', file.size, chunkSize);

    // Slice the video into NUM_CHUNKS and append each to the media element.
    var i = 0;

    (function readChunk_(i) {
      var reader = new FileReader();

      // Reads aren't guaranteed to finish in the same order they're started in,
      // so we need to read + append the next chunk after the previous reader
      // is done (onload is fired).
      reader.onload = function(e) {
		debugger;
		var data = {
			// Create a view
			data: Array.apply(null, new Uint8Array(e.target.result))
		};
		var transportData = JSON.stringify(data);
		
		console.log('posting chunk:', i);
		loaderPort.postMessage(transportData);
		
		if (i == NUM_CHUNKS - 1) {
		}
		else {
			readChunk_(++i);
		}
		
      };

      var startByte = chunkSize * i;
      var chunk = file.slice(startByte, startByte + chunkSize);

      reader.readAsArrayBuffer(chunk);
    })(i);  // Start the recursive call by self calling.
  });
  
  function GET(url, callback) {
  var xhr = new XMLHttpRequest();
  xhr.open('GET', url, true);
  xhr.responseType = 'arraybuffer';
  xhr.send();

  xhr.onload = function(e) {
    if (xhr.status != 200) {
      alert("Unexpected status code " + xhr.status + " for " + url);
      return false;
    }
    callback(new Uint8Array(xhr.response));
  };
}
}, 1000);
